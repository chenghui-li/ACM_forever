# 题目大意
给一个由左括号和右括号组成的序列，求有效括号的最长子串的长度。比如(()是"()",2;(()) 是“(())”,4;()(())是6

# 分析
比以前那个括号匹配的题难度要大。看了好久，最后还是学习下大牛的思想。

法1：用栈的思想来实现，只不过压入栈的不是括号，而是括号的下标。需要一个变量start来记录当前最长有效括号的起点位置。从左到右遍历序列，如果是左括号，则把它的下标压入栈中，如果是右括号，判断下栈是否为空，如果栈为空，则将起点start设置为该右括号的下一位；如果不是空，则将栈顶元素出栈，表示匹配成功，如果出栈后栈空，则更新结果和i-start+1，如果非空，则更新结果和i-stack.top()。
> 为什么要这么做呢？

考虑下，如果某次左右括号匹配成功，此时应该更新最大有效长度，更新的方式取决于前面的括号是否都匹配，如果前面的都匹配（栈空），那只需要累加就好；如果前面有不匹配的情况，还需进一步讨论，如果前面某次没有出现左括号的前提下出现一个右括号，那么显然有效长度的起点至少在它的后面；如果左右括号匹配的前提下，栈不为空，表示前面有多余的左括号出现，此时不能直接的累加，i-stack.top()表示此次匹配的长度。
# 实现
```
int longestValidParentheses(string s) {
        int len = s.size();
        stack<int> mys;
        int start = 0;
        int maxans = 0;
        for(int i = 0;i<len;i++){
            if(s[i] == '(')
                mys.push(i);
            else{
                if(mys.empty()){
                    start = i+1;
                }
                else{
                    mys.pop();
                    maxans = mys.empty() ?max(maxans,i-start+1):max(maxans,i-mys.top());
                }
            }
        }
        return maxans;
}
```

法2：使用动态规划的思想
