# 题目
把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。
# 分析
```
一个数若是丑数，则一定可以分解为2^x*3^y*5^z。
对于任何丑数p：
（一）那么2*p,3*p,5*p都是丑数，并且2*p<3*p<5*p
（二）如果p<q, 那么2\*p<2*q,3*p<3*q,5*p<5*q

暴力的方法就不说了，直接说学习到的O(n)的方法。
由于1是最小的丑数，那么从1开始，把2*1，3*1，5*1，进行比较，得出最小的就是1的下一个丑数，也就是2*1，
这个时候，又多了3个可以比较的丑数，2*2，3*2，5*2。但是没有必要将现在的5个数进行比较，因为1生成的三个丑数现在还剩下两个，而2生成的三个丑数的后两个肯定比第一个大，而此时第一个还未必被选中，所以后两个其实不用参与比较。
其实每次我们只用比较3个数：用于乘2的最小的数、用于乘3的最小的数，用于乘5的最小的
数。也就是比较(2*x , 3*y, 5*z) ，x>=y>=z的
```
# 实现
```
int GetUglyNumber_Solution(int index) {
        if(index < 1)
            return 0;
        long long  num[index];
        int i = 0;
        num[0] = 1;
        int t2,t3,t5;
        t5 = t2 = t3 = 0;
        for(int j = 1;j<index;j++){
            num[j] = min(num[t2]*2,min(num[t3]*3,num[t5]*5));
            if(num[j] == num[t2]*2){
                t2++;
            }
            if(num[j] == num[t3]*3)
                t3++;
            if(num[j] == num[t5]*5)
                t5++;
        }
        return num[index-1];
    }
```