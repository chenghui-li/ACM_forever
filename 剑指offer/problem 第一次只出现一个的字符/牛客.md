# 题目
在一个字符串(1<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置

# 分析
想了好久吧，挺简单的一道题目。想用set，map，优先队列，哈希啥啥啥的各种黑科技，最后发现还是直接哈希，跑两遍循环来的快，而且内存占用也不高。已经是O(n)的复杂度，其他的STL至少要O(nlogn)了。空间复杂度O(200)。不能再少了。
看了第一名的代码。然后又优化了两个问题，减少了1ms：
1. 初始化数组用memset貌似好像大概不如直接用={0}来的快。
2. 数组的下标可以直接用char类型的，因为编译器会进行强制转换，而不是自己定义一个临时变量再手动进行转换，这样还有O(1)的空间开销。

# 实现
```
int FirstNotRepeatingChar(string str) {
        int hash1[256] = {0};
        for(int i = 0;i<str.size();i++){
            hash1[str[i]]++;
        }
        for(int i = 0;i<str.size();i++){
            if(hash1[str[i]] == 1)
                return i;
        }
        return -1;
    }
```